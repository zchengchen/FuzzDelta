Human: 
            You are an expect to help detecting vulnerabilities introduced by commits. The commit information is shown as follows:
            Diff:
@@ -327,15 +327,15 @@ static ngx_int_t
 ngx_http_geo_addr(ngx_http_request_t *r, ngx_http_geo_ctx_t *ctx,
     ngx_addr_t *addr)
 {
-    ngx_array_t  *xfwd;
+    ngx_table_elt_t  *xfwd;
 
     if (ngx_http_geo_real_addr(r, ctx, addr) != NGX_OK) {
         return NGX_ERROR;
     }
 
-    xfwd = &r->headers_in.x_forwarded_for;
+    xfwd = r->headers_in.x_forwarded_for;
 
-    if (xfwd->nelts > 0 && ctx->proxies != NULL) {
+    if (xfwd != NULL && ctx->proxies != NULL) {
         (void) ngx_http_get_forwarded_addr(r, addr, xfwd, NULL,
                                            ctx->proxies, ctx->proxy_recursive);
     }
Diff:
@@ -240,16 +240,16 @@ static u_long
 ngx_http_geoip_addr(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)
 {
     ngx_addr_t           addr;
-    ngx_array_t         *xfwd;
+    ngx_table_elt_t     *xfwd;
     struct sockaddr_in  *sin;
 
     addr.sockaddr = r->connection->sockaddr;
     addr.socklen = r->connection->socklen;
     /* addr.name = r->connection->addr_text; */
 
-    xfwd = &r->headers_in.x_forwarded_for;
+    xfwd = r->headers_in.x_forwarded_for;
 
-    if (xfwd->nelts > 0 && gcf->proxies != NULL) {
+    if (xfwd != NULL && gcf->proxies != NULL) {
         (void) ngx_http_get_forwarded_addr(r, &addr, xfwd, NULL,
                                            gcf->proxies, gcf->proxy_recursive);
     }
@@ -292,7 +292,7 @@ static geoipv6_t
 ngx_http_geoip_addr_v6(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)
 {
     ngx_addr_t            addr;
-    ngx_array_t          *xfwd;
+    ngx_table_elt_t      *xfwd;
     in_addr_t             addr4;
     struct in6_addr       addr6;
     struct sockaddr_in   *sin;
@@ -302,9 +302,9 @@ ngx_http_geoip_addr_v6(ngx_http_request_t *r, ngx_http_geoip_conf_t *gcf)
     addr.socklen = r->connection->socklen;
     /* addr.name = r->connection->addr_text; */
 
-    xfwd = &r->headers_in.x_forwarded_for;
+    xfwd = r->headers_in.x_forwarded_for;
 
-    if (xfwd->nelts > 0 && gcf->proxies != NULL) {
+    if (xfwd != NULL && gcf->proxies != NULL) {
         (void) ngx_http_get_forwarded_addr(r, &addr, xfwd, NULL,
                                            gcf->proxies, gcf->proxy_recursive);
     }
Diff:
@@ -329,8 +329,7 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)
     time_t               now, expires_time, max_age;
     ngx_str_t            value;
     ngx_int_t            rc;
-    ngx_uint_t           i;
-    ngx_table_elt_t     *e, *cc, **ccp;
+    ngx_table_elt_t     *e, *cc;
     ngx_http_expires_t   expires;
 
     expires = conf->expires;
@@ -371,38 +370,28 @@ ngx_http_set_expires(ngx_http_request_t *r, ngx_http_headers_conf_t *conf)
     len = sizeof("Mon, 28 Sep 1970 06:00:00 GMT");
     e->value.len = len - 1;
 
-    ccp = r->headers_out.cache_control.elts;
+    cc = r->headers_out.cache_control;
 
-    if (ccp == NULL) {
-
-        if (ngx_array_init(&r->headers_out.cache_control, r->pool,
-                           1, sizeof(ngx_table_elt_t *))
-            != NGX_OK)
-        {
-            return NGX_ERROR;
-        }
+    if (cc == NULL) {
 
         cc = ngx_list_push(&r->headers_out.headers);
         if (cc == NULL) {
             return NGX_ERROR;
         }
 
+        r->headers_out.cache_control = cc;
+        cc->next = NULL;
+
         cc->hash = 1;
         ngx_str_set(&cc->key, "Cache-Control");
 
-        ccp = ngx_array_push(&r->headers_out.cache_control);
-        if (ccp == NULL) {
-            return NGX_ERROR;
-        }
-
-        *ccp = cc;
-
     } else {
-        for (i = 1; i < r->headers_out.cache_control.nelts; i++) {
-            ccp[i]->hash = 0;
+        for (cc = cc->next; cc; cc = cc->next) {
+            cc->hash = 0;
         }
 
-        cc = ccp[0];
+        cc = r->headers_out.cache_control;
+        cc->next = NULL;
     }
 
     if (expires == NGX_HTTP_EXPIRES_EPOCH) {
@@ -564,22 +553,12 @@ static ngx_int_t
 ngx_http_add_multi_header_lines(ngx_http_request_t *r,
     ngx_http_header_val_t *hv, ngx_str_t *value)
 {
-    ngx_array_t      *pa;
     ngx_table_elt_t  *h, **ph;
 
     if (value->len == 0) {
         return NGX_OK;
     }
 
-    pa = (ngx_array_t *) ((char *) &r->headers_out + hv->offset);
-
-    if (pa->elts == NULL) {
-        if (ngx_array_init(pa, r->pool, 1, sizeof(ngx_table_elt_t *)) != NGX_OK)
-        {
-            return NGX_ERROR;
-        }
-    }
-
     h = ngx_list_push(&r->headers_out.headers);
     if (h == NULL) {
         return NGX_ERROR;
@@ -589,12 +568,12 @@ ngx_http_add_multi_header_lines(ngx_http_request_t *r,
     h->key = hv->key;
     h->value = *value;
 
-    ph = ngx_array_push(pa);
-    if (ph == NULL) {
-        return NGX_ERROR;
-    }
+    ph = (ngx_table_elt_t **) ((char *) &r->headers_out + hv->offset);
+
+    while (*ph) { ph = &(*ph)->next; }
 
     *ph = h;
+    h->next = NULL;
 
     return NGX_OK;
 }
Diff:
@@ -2559,22 +2559,20 @@ static ngx_int_t
 ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r,
     ngx_http_variable_value_t *v, uintptr_t data)
 {
-    size_t             len;
-    u_char            *p;
-    ngx_uint_t         i, n;
-    ngx_table_elt_t  **h;
+    size_t            len;
+    u_char           *p;
+    ngx_table_elt_t  *h, *xfwd;
 
     v->valid = 1;
     v->no_cacheable = 0;
     v->not_found = 0;
 
-    n = r->headers_in.x_forwarded_for.nelts;
-    h = r->headers_in.x_forwarded_for.elts;
+    xfwd = r->headers_in.x_forwarded_for;
 
     len = 0;
 
-    for (i = 0; i < n; i++) {
-        len += h[i]->value.len + sizeof(", ") - 1;
+    for (h = xfwd; h; h = h->next) {
+        len += h->value.len + sizeof(", ") - 1;
     }
 
     if (len == 0) {
@@ -2593,8 +2591,8 @@ ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r,
     v->len = len;
     v->data = p;
 
-    for (i = 0; i < n; i++) {
-        p = ngx_copy(p, h[i]->value.data, h[i]->value.len);
+    for (h = xfwd; h; h = h->next) {
+        p = ngx_copy(p, h->value.data, h->value.len);
         *p++ = ','; *p++ = ' ';
     }
 
Diff:
@@ -134,9 +134,8 @@ ngx_http_realip_handler(ngx_http_request_t *r)
     ngx_str_t                   *value;
     ngx_uint_t                   i, hash;
     ngx_addr_t                   addr;
-    ngx_array_t                 *xfwd;
     ngx_list_part_t             *part;
-    ngx_table_elt_t             *header;
+    ngx_table_elt_t             *header, *xfwd;
     ngx_connection_t            *c;
     ngx_http_realip_ctx_t       *ctx;
     ngx_http_realip_loc_conf_t  *rlcf;
@@ -168,9 +167,9 @@ ngx_http_realip_handler(ngx_http_request_t *r)
 
     case NGX_HTTP_REALIP_XFWD:
 
-        xfwd = &r->headers_in.x_forwarded_for;
+        xfwd = r->headers_in.x_forwarded_for;
 
-        if (xfwd->elts == NULL) {
+        if (xfwd == NULL) {
             return NGX_DECLINED;
         }
 
Diff:
@@ -319,10 +319,9 @@ ngx_http_userid_set_variable(ngx_http_request_t *r,
 static ngx_http_userid_ctx_t *
 ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)
 {
-    ngx_int_t                n;
-    ngx_str_t                src, dst;
-    ngx_table_elt_t        **cookies;
-    ngx_http_userid_ctx_t   *ctx;
+    ngx_str_t               src, dst;
+    ngx_table_elt_t        *cookie;
+    ngx_http_userid_ctx_t  *ctx;
 
     ctx = ngx_http_get_module_ctx(r, ngx_http_userid_filter_module);
 
@@ -339,20 +338,19 @@ ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)
         ngx_http_set_ctx(r, ctx, ngx_http_userid_filter_module);
     }
 
-    n = ngx_http_parse_multi_header_lines(&r->headers_in.cookies, &conf->name,
-                                          &ctx->cookie);
-    if (n == NGX_DECLINED) {
+    cookie = ngx_http_parse_multi_header_lines(r, r->headers_in.cookie,
+                                               &conf->name, &ctx->cookie);
+    if (cookie == NULL) {
         return ctx;
     }
 
     ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                    "uid cookie: \"%V\"", &ctx->cookie);
 
     if (ctx->cookie.len < 22) {
-        cookies = r->headers_in.cookies.elts;
         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                       "client sent too short userid cookie \"%V\"",
-                      &cookies[n]->value);
+                      &cookie->value);
         return ctx;
     }
 
@@ -361,10 +359,9 @@ ngx_http_userid_get_uid(ngx_http_request_t *r, ngx_http_userid_conf_t *conf)
     dst.data = (u_char *) ctx->uid_got;
 
     if (ngx_decode_base64(&dst, &src) == NGX_ERROR) {
-        cookies = r->headers_in.cookies.elts;
         ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
                       "client sent invalid userid cookie \"%V\"",
-                      &cookies[n]->value);
+                      &cookie->value);
         return ctx;
     }
 
Diff:
@@ -302,7 +302,7 @@ header_in(r, key)
 
     if (hh) {
 
-        if (hh->offset == offsetof(ngx_http_headers_in_t, cookies)) {
+        if (hh->offset == offsetof(ngx_http_headers_in_t, cookie)) {
             sep = ';';
             goto multi;
         }
@@ -327,26 +327,22 @@ header_in(r, key)
 
         /* Cookie, X-Forwarded-For */
 
-        a = (ngx_array_t *) ((char *) &r->headers_in + hh->offset);
-
-        n = a->nelts;
+        ph = (ngx_table_elt_t **) ((char *) &r->headers_in + hh->offset);
 
-        if (n == 0) {
+        if (*ph == NULL) {
             XSRETURN_UNDEF;
         }
 
-        ph = a->elts;
-
-        if (n == 1) {
+        if ((*ph)->next == NULL) {
             ngx_http_perl_set_targ((*ph)->value.data, (*ph)->value.len);
 
             goto done;
         }
 
         size = - (ssize_t) (sizeof("; ") - 1);
 
-        for (i = 0; i < n; i++) {
-            size += ph[i]->value.len + sizeof("; ") - 1;
+        for (h = *ph; h; h = h->next) {
+            size += h->value.len + sizeof("; ") - 1;
         }
 
         value = ngx_pnalloc(r->pool, size);
@@ -357,10 +353,10 @@ header_in(r, key)
 
         p = value;
 
-        for (i = 0; /* void */ ; i++) {
-            p = ngx_copy(p, ph[i]->value.data, ph[i]->value.len);
+        for (h = *ph; h; h = h->next) {
+            p = ngx_copy(p, h->value.data, h->value.len);
 
-            if (i == n - 1) {
+            if (h->next == NULL) {
                 break;
             }
 
Diff:
@@ -103,10 +103,10 @@ ngx_int_t ngx_http_parse_unsafe_uri(ngx_http_request_t *r, ngx_str_t *uri,
     ngx_str_t *args, ngx_uint_t *flags);
 ngx_int_t ngx_http_parse_header_line(ngx_http_request_t *r, ngx_buf_t *b,
     ngx_uint_t allow_underscores);
-ngx_int_t ngx_http_parse_multi_header_lines(ngx_array_t *headers,
-    ngx_str_t *name, ngx_str_t *value);
-ngx_int_t ngx_http_parse_set_cookie_lines(ngx_array_t *headers,
-    ngx_str_t *name, ngx_str_t *value);
+ngx_table_elt_t *ngx_http_parse_multi_header_lines(ngx_http_request_t *r,
+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value);
+ngx_table_elt_t *ngx_http_parse_set_cookie_lines(ngx_http_request_t *r,
+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value);
 ngx_int_t ngx_http_arg(ngx_http_request_t *r, u_char *name, size_t len,
     ngx_str_t *value);
 void ngx_http_split_args(ngx_http_request_t *r, ngx_str_t *uri,
Diff:
@@ -2024,8 +2024,7 @@ ngx_http_gzip_ok(ngx_http_request_t *r)
 {
     time_t                     date, expires;
     ngx_uint_t                 p;
-    ngx_array_t               *cc;
-    ngx_table_elt_t           *e, *d, *ae;
+    ngx_table_elt_t           *e, *d, *ae, *cc;
     ngx_http_core_loc_conf_t  *clcf;
 
     r->gzip_tested = 1;
@@ -2118,30 +2117,30 @@ ngx_http_gzip_ok(ngx_http_request_t *r)
         return NGX_DECLINED;
     }
 
-    cc = &r->headers_out.cache_control;
+    cc = r->headers_out.cache_control;
 
-    if (cc->elts) {
+    if (cc) {
 
         if ((p & NGX_HTTP_GZIP_PROXIED_NO_CACHE)
-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_no_cache,
+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_no_cache,
                                                  NULL)
-               >= 0)
+               != NULL)
         {
             goto ok;
         }
 
         if ((p & NGX_HTTP_GZIP_PROXIED_NO_STORE)
-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_no_store,
+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_no_store,
                                                  NULL)
-               >= 0)
+               != NULL)
         {
             goto ok;
         }
 
         if ((p & NGX_HTTP_GZIP_PROXIED_PRIVATE)
-            && ngx_http_parse_multi_header_lines(cc, &ngx_http_gzip_private,
+            && ngx_http_parse_multi_header_lines(r, cc, &ngx_http_gzip_private,
                                                  NULL)
-               >= 0)
+               != NULL)
         {
             goto ok;
         }
@@ -2712,29 +2711,36 @@ ngx_http_set_disable_symlinks(ngx_http_request_t *r,
 
 ngx_int_t
 ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,
-    ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,
+    ngx_table_elt_t *headers, ngx_str_t *value, ngx_array_t *proxies,
     int recursive)
 {
-    ngx_int_t          rc;
-    ngx_uint_t         i, found;
-    ngx_table_elt_t  **h;
+    ngx_int_t         rc;
+    ngx_uint_t        found;
+    ngx_table_elt_t  *h, *next;
 
     if (headers == NULL) {
         return ngx_http_get_forwarded_addr_internal(r, addr, value->data,
                                                     value->len, proxies,
                                                     recursive);
     }
 
-    i = headers->nelts;
-    h = headers->elts;
+    /* revert headers order */
+
+    for (h = headers, headers = NULL; h; h = next) {
+        next = h->next;
+        h->next = headers;
+        headers = h;
+    }
+
+    /* iterate over all headers in reverse order */
 
     rc = NGX_DECLINED;
 
     found = 0;
 
-    while (i-- > 0) {
-        rc = ngx_http_get_forwarded_addr_internal(r, addr, h[i]->value.data,
-                                                  h[i]->value.len, proxies,
+    for (h = headers; h; h = h->next) {
+        rc = ngx_http_get_forwarded_addr_internal(r, addr, h->value.data,
+                                                  h->value.len, proxies,
                                                   recursive);
 
         if (!recursive) {
@@ -2753,6 +2759,14 @@ ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,
         found = 1;
     }
 
+    /* restore headers order */
+
+    for (h = headers, headers = NULL; h; h = next) {
+        next = h->next;
+        h->next = headers;
+        headers = h;
+    }
+
     return rc;
 }
 
Diff:
@@ -532,7 +532,7 @@ ngx_int_t ngx_http_set_disable_symlinks(ngx_http_request_t *r,
     ngx_http_core_loc_conf_t *clcf, ngx_str_t *path, ngx_open_file_info_t *of);
 
 ngx_int_t ngx_http_get_forwarded_addr(ngx_http_request_t *r, ngx_addr_t *addr,
-    ngx_array_t *headers, ngx_str_t *value, ngx_array_t *proxies,
+    ngx_table_elt_t *headers, ngx_str_t *value, ngx_array_t *proxies,
     int recursive);
 
 ngx_int_t ngx_http_link_multi_headers(ngx_http_request_t *r);
Diff:
@@ -1960,27 +1960,24 @@ ngx_http_parse_unsafe_uri(ngx_http_request_t *r, ngx_str_t *uri,
 }
 
 
-ngx_int_t
-ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,
-    ngx_str_t *value)
+ngx_table_elt_t *
+ngx_http_parse_multi_header_lines(ngx_http_request_t *r,
+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value)
 {
-    ngx_uint_t         i;
-    u_char            *start, *last, *end, ch;
-    ngx_table_elt_t  **h;
-
-    h = headers->elts;
+    u_char           *start, *last, *end, ch;
+    ngx_table_elt_t  *h;
 
-    for (i = 0; i < headers->nelts; i++) {
+    for (h = headers; h; h = h->next) {
 
-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, headers->pool->log, 0,
-                       "parse header: \"%V: %V\"", &h[i]->key, &h[i]->value);
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "parse header: \"%V: %V\"", &h->key, &h->value);
 
-        if (name->len > h[i]->value.len) {
+        if (name->len > h->value.len) {
             continue;
         }
 
-        start = h[i]->value.data;
-        end = h[i]->value.data + h[i]->value.len;
+        start = h->value.data;
+        end = h->value.data + h->value.len;
 
         while (start < end) {
 
@@ -1994,7 +1991,7 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,
 
             if (value == NULL) {
                 if (start == end || *start == ',') {
-                    return i;
+                    return h;
                 }
 
                 goto skip;
@@ -2014,7 +2011,7 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,
             value->len = last - start;
             value->data = start;
 
-            return i;
+            return h;
 
         skip:
 
@@ -2029,31 +2026,28 @@ ngx_http_parse_multi_header_lines(ngx_array_t *headers, ngx_str_t *name,
         }
     }
 
-    return NGX_DECLINED;
+    return NULL;
 }
 
 
-ngx_int_t
-ngx_http_parse_set_cookie_lines(ngx_array_t *headers, ngx_str_t *name,
-    ngx_str_t *value)
+ngx_table_elt_t *
+ngx_http_parse_set_cookie_lines(ngx_http_request_t *r,
+    ngx_table_elt_t *headers, ngx_str_t *name, ngx_str_t *value)
 {
-    ngx_uint_t         i;
-    u_char            *start, *last, *end;
-    ngx_table_elt_t  **h;
-
-    h = headers->elts;
+    u_char           *start, *last, *end;
+    ngx_table_elt_t  *h;
 
-    for (i = 0; i < headers->nelts; i++) {
+    for (h = headers; h; h = h->next) {
 
-        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, headers->pool->log, 0,
-                       "parse header: \"%V: %V\"", &h[i]->key, &h[i]->value);
+        ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
+                       "parse header: \"%V: %V\"", &h->key, &h->value);
 
-        if (name->len >= h[i]->value.len) {
+        if (name->len >= h->value.len) {
             continue;
         }
 
-        start = h[i]->value.data;
-        end = h[i]->value.data + h[i]->value.len;
+        start = h->value.data;
+        end = h->value.data + h->value.len;
 
         if (ngx_strncasecmp(start, name->data, name->len) != 0) {
             continue;
@@ -2077,10 +2071,10 @@ ngx_http_parse_set_cookie_lines(ngx_array_t *headers, ngx_str_t *name,
         value->len = last - start;
         value->data = start;
 
-        return i;
+        return h;
     }
 
-    return NGX_DECLINED;
+    return NULL;
 }
 
 
Diff:
@@ -46,6 +46,7 @@ static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c,
     ngx_http_request_t *r, ngx_http_core_srv_conf_t **cscfp);
 
 static void ngx_http_request_handler(ngx_event_t *ev);
+static ngx_int_t ngx_http_trace_handler(ngx_http_request_t *r);
 static void ngx_http_terminate_request(ngx_http_request_t *r, ngx_int_t rc);
 static void ngx_http_terminate_handler(ngx_http_request_t *r);
 static void ngx_http_finalize_connection(ngx_http_request_t *r);
@@ -205,7 +206,7 @@ ngx_http_header_t  ngx_http_headers_in[] = {
                  ngx_http_process_header_line },
 #endif
 
-    { ngx_string("Cookie"), offsetof(ngx_http_headers_in_t, cookies),
+    { ngx_string("Cookie"), offsetof(ngx_http_headers_in_t, cookie),
                  ngx_http_process_multi_header_lines },
 
     { ngx_string("Black-List"), offsetof(ngx_http_headers_in_t, black_list),
@@ -1768,6 +1769,7 @@ ngx_http_process_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,
 
     if (*ph == NULL) {
         *ph = h;
+        h->next = NULL;
     }
 
     return NGX_OK;
@@ -1784,6 +1786,7 @@ ngx_http_process_unique_header_line(ngx_http_request_t *r, ngx_table_elt_t *h,
 
     if (*ph == NULL) {
         *ph = h;
+        h->next = NULL;
         return NGX_OK;
     }
 
@@ -1816,6 +1819,7 @@ ngx_http_process_host(ngx_http_request_t *r, ngx_table_elt_t *h,
     }
 
     r->headers_in.host = h;
+    h->next = NULL;
 
     host = h->value;
 
@@ -1877,6 +1881,7 @@ ngx_http_process_user_agent(ngx_http_request_t *r, ngx_table_elt_t *h,
     }
 
     r->headers_in.user_agent = h;
+    h->next = NULL;
 
     /* check some widespread browsers while the header is in CPU cache */
 
@@ -1943,34 +1948,24 @@ static ngx_int_t
 ngx_http_process_multi_header_lines(ngx_http_request_t *r, ngx_table_elt_t *h,
     ngx_uint_t offset)
 {
-    ngx_array_t       *headers;
     ngx_table_elt_t  **ph;
 
-    headers = (ngx_array_t *) ((char *) &r->headers_in + offset);
-
-    if (headers->elts == NULL) {
-        if (ngx_array_init(headers, r->pool, 1, sizeof(ngx_table_elt_t *))
-            != NGX_OK)
-        {
-            ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
-            return NGX_ERROR;
-        }
-    }
+    ph = (ngx_table_elt_t **) ((char *) &r->headers_in + offset);
 
-    ph = ngx_array_push(headers);
-    if (ph == NULL) {
-        ngx_http_close_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
-        return NGX_ERROR;
-    }
+    while (*ph) { ph = &(*ph)->next; }
 
     *ph = h;
+    h->next = NULL;
+
     return NGX_OK;
 }
 
 
 ngx_int_t
 ngx_http_process_request_header(ngx_http_request_t *r)
 {
+    ngx_core_conf_t *ccf = (ngx_core_conf_t *) ngx_get_conf(r->cycle->conf_ctx, ngx_core_module);
+
     if (r->headers_in.server.len == 0
         && ngx_http_set_virtual_server(r, &r->headers_in.server)
            == NGX_ERROR)
@@ -2049,8 +2044,12 @@ ngx_http_process_request_header(ngx_http_request_t *r)
     if (r->method == NGX_HTTP_TRACE) {
         ngx_log_error(NGX_LOG_INFO, r->connection->log, 0,
                       "client sent TRACE method");
-        ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);
-        return NGX_ERROR;
+          if (ccf->trace_enable != -1) {
+               return ngx_http_trace_handler(r);
+          } else {
+               ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);
+               return NGX_ERROR;
+          }
     }
 
     return NGX_OK;
@@ -4049,3 +4048,65 @@ ngx_http_process_prefer(ngx_http_request_t *r, ngx_table_elt_t *h,
 
     return NGX_OK;
 }
+
+
+static ngx_int_t
+ngx_http_trace_handler(ngx_http_request_t *r)
+{
+    ngx_list_part_t *part;
+    ngx_table_elt_t *header;
+    ngx_buf_t *b;
+    ngx_chain_t out;
+    ngx_int_t rc, content_len;
+
+    b = ngx_create_temp_buf(r->pool, 200);
+    if (b == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    b->last = ngx_copy(b->last, r->request_line.data, r->request_line.len);
+    *b->last++ = '\n';
+
+    content_len = r->request_line.len + 1;
+
+    part = &r->headers_in.headers.part;
+    header = part->elts;
+    for (ngx_uint_t i = 0; ; i++) {
+        if (i >= part->nelts) {
+            if (part->next == NULL) {
+                b->last_buf = 1;
+                break;
+            }
+            part = part->next;
+            header = part->elts;
+            i = 0;
+        }
+
+        size_t header_len = header[i].key.len + header[i].value.len + 3;
+        content_len += header_len;
+
+        b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);
+        *b->last++ = ':';
+        *b->last++ = ' ';
+        b->last = ngx_copy(b->last, header[i].value.data, header[i].value.len);
+        *b->last++ = '\n';
+    }
+
+    ngx_str_t ct = ngx_string("message/http");
+    r->headers_out.status = NGX_HTTP_OK;
+    r->headers_out.content_type = ct;
+    r->headers_out.content_length_n = content_len;
+    rc = ngx_http_send_header(r);
+
+    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {
+        return rc;
+    }
+
+    out.buf = b;
+    out.next = NULL;
+
+    rc = ngx_http_output_filter(r, &out);
+    ngx_http_close_request(r, rc);
+
+    return NGX_DONE;
+}
Diff:
@@ -214,7 +214,7 @@ typedef struct {
     ngx_table_elt_t                  *keep_alive;
 
 #if (NGX_HTTP_X_FORWARDED_FOR)
-    ngx_array_t                       x_forwarded_for;
+    ngx_table_elt_t                  *x_forwarded_for;
 #endif
 
 #if (NGX_HTTP_REALIP)
@@ -233,11 +233,11 @@ typedef struct {
     ngx_table_elt_t                  *date;
 #endif
 
+    ngx_table_elt_t                  *cookie;
+
     ngx_str_t                         user;
     ngx_str_t                         passwd;
 
-    ngx_array_t                       cookies;
-
     ngx_str_t                         server;
     off_t                             content_length_n;
     time_t                            keep_alive_n;
@@ -279,6 +279,9 @@ typedef struct {
     ngx_table_elt_t                  *expires;
     ngx_table_elt_t                  *etag;
 
+    ngx_table_elt_t                  *cache_control;
+    ngx_table_elt_t                  *link;
+
     ngx_str_t                        *override_charset;
 
     size_t                            content_type_len;
@@ -287,9 +290,6 @@ typedef struct {
     u_char                           *content_type_lowcase;
     ngx_uint_t                        content_type_hash;
 
-    ngx_array_t                       cache_control;
-    ngx_array_t                       link;
-
     off_t                             content_length_n;
     off_t                             content_offset;
     time_t                            date_time;
Diff:
@@ -246,7 +246,7 @@ static ngx_http_upstream_header_t  ngx_http_upstream_headers_in[] = {
 
     { ngx_string("Set-Cookie"),
                  ngx_http_upstream_process_set_cookie,
-                 offsetof(ngx_http_upstream_headers_in_t, cookies),
+                 offsetof(ngx_http_upstream_headers_in_t, set_cookie),
                  ngx_http_upstream_rewrite_set_cookie, 0, 1 },
 
     { ngx_string("Content-Disposition"),
@@ -4666,26 +4666,16 @@ static ngx_int_t
 ngx_http_upstream_process_set_cookie(ngx_http_request_t *r, ngx_table_elt_t *h,
     ngx_uint_t offset)
 {
-    ngx_array_t           *pa;
     ngx_table_elt_t      **ph;
     ngx_http_upstream_t   *u;
 
     u = r->upstream;
-    pa = &u->headers_in.cookies;
+    ph = &u->headers_in.set_cookie;
 
-    if (pa->elts == NULL) {
-        if (ngx_array_init(pa, r->pool, 1, sizeof(ngx_table_elt_t *)) != NGX_OK)
-        {
-            return NGX_ERROR;
-        }
-    }
-
-    ph = ngx_array_push(pa);
-    if (ph == NULL) {
-        return NGX_ERROR;
-    }
+    while (*ph) { ph = &(*ph)->next; }
 
     *ph = h;
+    h->next = NULL;
 
 #if (NGX_HTTP_CACHE)
     if (!(u->conf->ignore_headers & NGX_HTTP_UPSTREAM_IGN_SET_COOKIE)) {
@@ -4701,26 +4691,16 @@ static ngx_int_t
 ngx_http_upstream_process_cache_control(ngx_http_request_t *r,
     ngx_table_elt_t *h, ngx_uint_t offset)
 {
-    ngx_array_t          *pa;
     ngx_table_elt_t     **ph;
     ngx_http_upstream_t  *u;
 
     u = r->upstream;
-    pa = &u->headers_in.cache_control;
+    ph = &u->headers_in.cache_control;
 
-    if (pa->elts == NULL) {
-        if (ngx_array_init(pa, r->pool, 2, sizeof(ngx_table_elt_t *)) != NGX_OK)
-        {
-            return NGX_ERROR;
-        }
-    }
-
-    ph = ngx_array_push(pa);
-    if (ph == NULL) {
-        return NGX_ERROR;
-    }
+    while (*ph) { ph = &(*ph)->next; }
 
     *ph = h;
+    h->next = NULL;
 
 #if (NGX_HTTP_CACHE)
     {
@@ -5103,31 +5083,21 @@ static ngx_int_t
 ngx_http_upstream_copy_multi_header_lines(ngx_http_request_t *r,
     ngx_table_elt_t *h, ngx_uint_t offset)
 {
-    ngx_array_t      *pa;
     ngx_table_elt_t  *ho, **ph;
 
-    pa = (ngx_array_t *) ((char *) &r->headers_out + offset);
-
-    if (pa->elts == NULL) {
-        if (ngx_array_init(pa, r->pool, 2, sizeof(ngx_table_elt_t *)) != NGX_OK)
-        {
-            return NGX_ERROR;
-        }
-    }
-
     ho = ngx_list_push(&r->headers_out.headers);
     if (ho == NULL) {
         return NGX_ERROR;
     }
 
     *ho = *h;
 
-    ph = ngx_array_push(pa);
-    if (ph == NULL) {
-        return NGX_ERROR;
-    }
+    ph = (ngx_table_elt_t **) ((char *) &r->headers_out + offset);
+
+    while (*ph) { ph = &(*ph)->next; }
 
     *ph = ho;
+    ho->next = NULL;
 
     return NGX_OK;
 }
@@ -5740,9 +5710,9 @@ ngx_http_upstream_cookie_variable(ngx_http_request_t *r,
     s.len = name->len - (sizeof("upstream_cookie_") - 1);
     s.data = name->data + sizeof("upstream_cookie_") - 1;
 
-    if (ngx_http_parse_set_cookie_lines(&r->upstream->headers_in.cookies,
+    if (ngx_http_parse_set_cookie_lines(r, r->upstream->headers_in.set_cookie,
                                         &s, &cookie)
-        == NGX_DECLINED)
+        == NULL)
     {
         v->not_found = 1;
         return NGX_OK;
Diff:
@@ -289,8 +289,8 @@ typedef struct {
     ngx_table_elt_t                 *content_encoding;
 #endif
 
-    ngx_array_t                      cache_control;
-    ngx_array_t                      cookies;
+    ngx_table_elt_t                 *cache_control;
+    ngx_table_elt_t                 *set_cookie;
 
     off_t                            content_length_n;
     time_t                           last_modified_time;
Diff:
@@ -187,7 +187,7 @@ static ngx_http_variable_t  ngx_http_core_variables[] = {
 #endif
 
     { ngx_string("http_cookie"), NULL, ngx_http_variable_cookies,
-      offsetof(ngx_http_request_t, headers_in.cookies), 0, 0 },
+      offsetof(ngx_http_request_t, headers_in.cookie), 0, 0 },
 
     { ngx_string("content_length"), NULL, ngx_http_variable_content_length,
       0, 0, 0 },
@@ -856,26 +856,21 @@ static ngx_int_t
 ngx_http_variable_headers_internal(ngx_http_request_t *r,
     ngx_http_variable_value_t *v, uintptr_t data, u_char sep)
 {
-    size_t             len;
-    u_char            *p, *end;
-    ngx_uint_t         i, n;
-    ngx_array_t       *a;
-    ngx_table_elt_t  **h;
-
-    a = (ngx_array_t *) ((char *) r + data);
+    size_t            len;
+    u_char           *p;
+    ngx_table_elt_t  *h, *th;
 
-    n = a->nelts;
-    h = a->elts;
+    h = *(ngx_table_elt_t **) ((char *) r + data);
 
     len = 0;
 
-    for (i = 0; i < n; i++) {
+    for (th = h; th; th = th->next) {
 
-        if (h[i]->hash == 0) {
+        if (th->hash == 0) {
             continue;
         }
 
-        len += h[i]->value.len + 2;
+        len += th->value.len + 2;
     }
 
     if (len == 0) {
@@ -889,9 +884,9 @@ ngx_http_variable_headers_internal(ngx_http_request_t *r,
     v->no_cacheable = 0;
     v->not_found = 0;
 
-    if (n == 1) {
-        v->len = (*h)->value.len;
-        v->data = (*h)->value.data;
+    if (h->next == NULL) {
+        v->len = h->value.len;
+        v->data = h->value.data;
 
         return NGX_OK;
     }
@@ -904,17 +899,15 @@ ngx_http_variable_headers_internal(ngx_http_request_t *r,
     v->len = len;
     v->data = p;
 
-    end = p + len;
-
-    for (i = 0; /* void */ ; i++) {
+    for (th = h; th; th = th->next) {
 
-        if (h[i]->hash == 0) {
+        if (th->hash == 0) {
             continue;
         }
 
-        p = ngx_copy(p, h[i]->value.data, h[i]->value.len);
+        p = ngx_copy(p, th->value.data, th->value.len);
 
-        if (p == end) {
+        if (th->next == NULL) {
             break;
         }
 
@@ -1112,8 +1105,8 @@ ngx_http_variable_cookie(ngx_http_request_t *r, ngx_http_variable_value_t *v,
     s.len = name->len - (sizeof("cookie_") - 1);
     s.data = name->data + sizeof("cookie_") - 1;
 
-    if (ngx_http_parse_multi_header_lines(&r->headers_in.cookies, &s, &cookie)
-        == NGX_DECLINED)
+    if (ngx_http_parse_multi_header_lines(r, r->headers_in.cookie, &s, &cookie)
+        == NULL)
     {
         v->not_found = 1;
         return NGX_OK;
Diff:
@@ -674,14 +674,14 @@ ngx_http_v2_header_filter(ngx_http_request_t *r)
 static ngx_int_t
 ngx_http_v2_push_resources(ngx_http_request_t *r)
 {
-    u_char                     *start, *end, *last;
-    ngx_int_t                   rc;
-    ngx_str_t                   path;
-    ngx_uint_t                  i, push;
-    ngx_table_elt_t           **h;
-    ngx_http_v2_loc_conf_t     *h2lcf;
-    ngx_http_complex_value_t   *pushes;
-    ngx_str_t                   binary[NGX_HTTP_V2_PUSH_HEADERS];
+    u_char                    *start, *end, *last;
+    ngx_int_t                  rc;
+    ngx_str_t                  path;
+    ngx_uint_t                 i, push;
+    ngx_table_elt_t           *h;
+    ngx_http_v2_loc_conf_t    *h2lcf;
+    ngx_http_complex_value_t  *pushes;
+    ngx_str_t                  binary[NGX_HTTP_V2_PUSH_HEADERS];
 
     ngx_log_debug0(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                    "http2 push resources");
@@ -725,15 +725,13 @@ ngx_http_v2_push_resources(ngx_http_request_t *r)
         return NGX_OK;
     }
 
-    h = r->headers_out.link.elts;
-
-    for (i = 0; i < r->headers_out.link.nelts; i++) {
+    for (h = r->headers_out.link; h; h = h->next) {
 
         ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
-                       "http2 parse link: \"%V\"", &h[i]->value);
+                       "http2 parse link: \"%V\"", &h->value);
 
-        start = h[i]->value.data;
-        end = h[i]->value.data + h[i]->value.len;
+        start = h->value.data;
+        end = h->value.data + h->value.len;
 
     next_link:
 

            Does this commit introduce any new vulnerability? If this commit has new vulnerability, please tell me 'YES' in the first line and analyze the cause in the followings. Otherwise, please return 'NO'.
            Your cause should contain the following information:
            (1) Why this commit is vulnerable?
            (2) Under what conditions does the input trigger this vulnerability? The more detailed, the better.
        
LLM: 
YES

**(1) Why is this commit vulnerable?**

The commit introduces a vulnerability in the newly added `ngx_http_trace_handler` function, which is designed to handle HTTP TRACE requests in Nginx. The vulnerability is a buffer overflow caused by copying variable-length input data into a fixed-size buffer without proper bounds checking.

In the `ngx_http_trace_handler` function, a temporary buffer `b` of fixed size (200 bytes) is allocated:

```c
b = ngx_create_temp_buf(r->pool, 200);
if (b == NULL) {
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
}
```

Then, the function copies the request line and all header fields from the client's request into this buffer:

```c
b->last = ngx_copy(b->last, r->request_line.data, r->request_line.len);
*b->last++ = '\n';

content_len = r->request_line.len + 1;

// ...

size_t header_len = header[i].key.len + header[i].value.len + 3;
content_len += header_len;

b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);
*b->last++ = ':';
*b->last++ = ' ';
b->last = ngx_copy(b->last, header[i].value.data, header[i].value.len);
*b->last++ = '\n';
```

However, there is **no check** to ensure that the data being copied does not exceed the size of the buffer `b`. If a client sends a request with a request line and headers that total more than 200 bytes, this will result in writing beyond the allocated buffer, causing a **heap-based buffer overflow**.

This buffer overflow can lead to several security issues, including:

- **Application Crashes**: Overwriting adjacent memory can corrupt the program's memory space, causing Nginx to crash.
- **Denial of Service (DoS)**: An attacker can exploit this vulnerability to repeatedly crash the server, leading to a denial of service.
- **Remote Code Execution**: In some cases, carefully crafted input can be used to execute arbitrary code on the server, compromising the entire system.

**(2) Under what conditions does the input trigger this vulnerability?**

The vulnerability is triggered under the following conditions:

1. **HTTP TRACE Method Enabled**: The server must be configured to allow the HTTP TRACE method. In the provided code, this is controlled by the `trace_enable` directive:

   ```c
   if (ccf->trace_enable != -1) {
       return ngx_http_trace_handler(r);
   } else {
       ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);
       return NGX_ERROR;
   }
   ```

   The vulnerability exists only if `trace_enable` is set to a value other than `-1`.

2. **Oversized Request Line and Headers**: The client sends an HTTP TRACE request with a request line and headers that, when combined, exceed 200 bytes in length. For example:

   - A very long request URI:

     ```
     TRACE /very/long/request/uri/that/exceeds/the/buffer/limit HTTP/1.1
     ```

   - A large number of headers or headers with very long names and values:

     ```
     Header1: value1
     Header2: value2
     ...
     HeaderN: valueN
     ```

3. **Lack of Input Validation in the Handler**: The `ngx_http_trace_handler` function lacks bounds checking when copying data into the buffer `b`. Specifically, it does not verify that `b->last` does not exceed `b->end` after each copy operation.

An attacker can exploit this vulnerability by:

- Sending a specially crafted HTTP TRACE request with an excessively long request line or headers.
- Ensuring that the total length of the data copied into the buffer exceeds 200 bytes.
- Causing a buffer overflow that overwrites adjacent memory.

**Example of an Attack:**

An attacker could write a script that sends an HTTP TRACE request like the following:

```
TRACE /AAAAAAAAAA... (500 'A's) HTTP/1.1
Host: victim.example.com
Header1: BBBBBBBBB... (500 'B's)
Header2: CCCCCCCCC... (500 'C's)
```

By exceeding the buffer size, the attacker causes a buffer overflow, which can crash the server or potentially allow for arbitrary code execution.

**Conclusion:**

The commit introduces a buffer overflow vulnerability in the handling of HTTP TRACE requests due to improper handling of untrusted input data and the absence of necessary bounds checking when copying data into a fixed-size buffer.
Human: 
            You need to choose the one you need from the following harness and I will give you the file name and function description. Then tell me the filename you need. Just tell me the filename, no additional explanation or output is needed.
                1. pov_harness.cc
        vulnerabilities are primarily related to the request processing chain. Throughout the HTTP request's lifecycle from reception to response, issues may arise in request method parsing, URI normalization, header key-value parsing, route rule matching, and proxy configuration forwarding. Buffer overflows, memory leaks, or logical vulnerabilities are particularly likely when handling headers of abnormal length, malformed URIs, special cookie values, complex location configurations, or multi-layer proxy forwarding.
    2. mail_request_harness.cc
        vulnerabilities are mainly associated with state transitions and authentication flows. The authentication process involves interaction with the auth server (auth_http handling), authentication state validation (auth_done state), and result processing. As a stateful protocol, POP3 must strictly transition between AUTHORIZATION, TRANSACTION, and UPDATE states, each with its specific command set. Improper state transition handling or authentication flow flaws can lead to unauthorized access or state confusion.
    3. smtp_harness.cc
        vulnerabilities primarily relate to command processing and session management. The SMTP server must handle a series of commands from HELO/EHLO to MAIL FROM, RCPT TO, and DATA, each with its specific format and processing logic. Session states must maintain correct transitions from connection initialization through authentication to mail transfer. Security issues can particularly arise during long mail content processing, concurrent connections, or complex authentication scenarios due to incorrect command parsing or state management.        
LLM: 
pov_harness.cc
Human: 
            Your analysis about how to trigger the vulnerability before:
            YES

**(1) Why is this commit vulnerable?**

The commit introduces a vulnerability in the newly added `ngx_http_trace_handler` function, which is designed to handle HTTP TRACE requests in Nginx. The vulnerability is a buffer overflow caused by copying variable-length input data into a fixed-size buffer without proper bounds checking.

In the `ngx_http_trace_handler` function, a temporary buffer `b` of fixed size (200 bytes) is allocated:

```c
b = ngx_create_temp_buf(r->pool, 200);
if (b == NULL) {
    return NGX_HTTP_INTERNAL_SERVER_ERROR;
}
```

Then, the function copies the request line and all header fields from the client's request into this buffer:

```c
b->last = ngx_copy(b->last, r->request_line.data, r->request_line.len);
*b->last++ = '\n';

content_len = r->request_line.len + 1;

// ...

size_t header_len = header[i].key.len + header[i].value.len + 3;
content_len += header_len;

b->last = ngx_copy(b->last, header[i].key.data, header[i].key.len);
*b->last++ = ':';
*b->last++ = ' ';
b->last = ngx_copy(b->last, header[i].value.data, header[i].value.len);
*b->last++ = '\n';
```

However, there is **no check** to ensure that the data being copied does not exceed the size of the buffer `b`. If a client sends a request with a request line and headers that total more than 200 bytes, this will result in writing beyond the allocated buffer, causing a **heap-based buffer overflow**.

This buffer overflow can lead to several security issues, including:

- **Application Crashes**: Overwriting adjacent memory can corrupt the program's memory space, causing Nginx to crash.
- **Denial of Service (DoS)**: An attacker can exploit this vulnerability to repeatedly crash the server, leading to a denial of service.
- **Remote Code Execution**: In some cases, carefully crafted input can be used to execute arbitrary code on the server, compromising the entire system.

**(2) Under what conditions does the input trigger this vulnerability?**

The vulnerability is triggered under the following conditions:

1. **HTTP TRACE Method Enabled**: The server must be configured to allow the HTTP TRACE method. In the provided code, this is controlled by the `trace_enable` directive:

   ```c
   if (ccf->trace_enable != -1) {
       return ngx_http_trace_handler(r);
   } else {
       ngx_http_finalize_request(r, NGX_HTTP_NOT_ALLOWED);
       return NGX_ERROR;
   }
   ```

   The vulnerability exists only if `trace_enable` is set to a value other than `-1`.

2. **Oversized Request Line and Headers**: The client sends an HTTP TRACE request with a request line and headers that, when combined, exceed 200 bytes in length. For example:

   - A very long request URI:

     ```
     TRACE /very/long/request/uri/that/exceeds/the/buffer/limit HTTP/1.1
     ```

   - A large number of headers or headers with very long names and values:

     ```
     Header1: value1
     Header2: value2
     ...
     HeaderN: valueN
     ```

3. **Lack of Input Validation in the Handler**: The `ngx_http_trace_handler` function lacks bounds checking when copying data into the buffer `b`. Specifically, it does not verify that `b->last` does not exceed `b->end` after each copy operation.

An attacker can exploit this vulnerability by:

- Sending a specially crafted HTTP TRACE request with an excessively long request line or headers.
- Ensuring that the total length of the data copied into the buffer exceeds 200 bytes.
- Causing a buffer overflow that overwrites adjacent memory.

**Example of an Attack:**

An attacker could write a script that sends an HTTP TRACE request like the following:

```
TRACE /AAAAAAAAAA... (500 'A's) HTTP/1.1
Host: victim.example.com
Header1: BBBBBBBBB... (500 'B's)
Header2: CCCCCCCCC... (500 'C's)
```

By exceeding the buffer size, the attacker causes a buffer overflow, which can crash the server or potentially allow for arbitrary code execution.

**Conclusion:**

The commit introduces a buffer overflow vulnerability in the handling of HTTP TRACE requests due to improper handling of untrusted input data and the absence of necessary bounds checking when copying data into a fixed-size buffer.
            The implementation of harness you need is shown as follows:
            // Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////////////////////
extern "C" {
  #include <ngx_config.h>
  #include <ngx_core.h>
  #include <ngx_event.h>
  #include <ngx_http.h>
  #include <sys/sendfile.h>
  }
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <sys/stat.h>
  #include <time.h>
  #include <unistd.h>
  #include <sys/uio.h>
  
  static char configuration[] =
  "error_log stderr emerg;\n"
  "trace on;\n"
  "worker_rlimit_nofile 8192;\n"
  "pid logs/nginx.pid;\n"
  "remote_admin off;\n"
  "events {\n"
  "    worker_connections 2;\n"
  "    multi_accept off;\n"
  "    accept_mutex off;\n"
  "}\n"
  "http {\n"
  "    server_tokens off;\n"
  "    sendfile        on;\n"
  "    default_type application/octet-stream;\n"
  "    map $http_upgrade $connection_upgrade {\n"
  "      default upgrade;\n"
  "      '' close;\n"
  "    }\n"
  "    error_log stderr emerg;\n"
  "    access_log stderr;\n"
  "    map $subdomain $nss {\n"
  "      default local_upstream;\n"
  "    }\n"
  "    upstream local_upstream {\n"
  "      server 127.0.0.1:1010 max_fails=0;\n"
  "      server 127.0.0.1:1011 max_fails=0;\n"
  "      server 127.0.0.1:1012 max_fails=0;\n"
  "      server 127.0.0.1:1013 max_fails=0;\n"
  "      server 127.0.0.1:1014 max_fails=0;\n"
  "      server 127.0.0.1:1015 max_fails=0;\n"
  "      server 127.0.0.1:1016 max_fails=0;\n"
  "      server 127.0.0.1:1017 max_fails=0;\n"
  "      server 127.0.0.1:1018 max_fails=0;\n"
  "      server 127.0.0.1:1019 max_fails=0;\n"
  "    }\n"
  "    map $http_user_agent $is_modern_browser {\n"
  "        default         0;\n"
  "        \"~*Firefox\"     1;\n"
  "        \"~*Chrome\"      1;\n"
  "        \"~*Safari\"      1;\n"
  "        \"~*Opera\"       1;\n"
  "        \"~*Edge\"        1;\n"
  "    }\n"
  "    client_max_body_size 256M;\n"
  "    client_body_temp_path /tmp/;\n"
  "    proxy_temp_path /tmp/;\n"
  "    proxy_buffer_size 24K;\n"
  "    proxy_max_temp_file_size 0;\n"
  "    proxy_buffers 8 4K;\n"
  "    proxy_busy_buffers_size 28K;\n"
  "    proxy_buffering off;\n"
  "    server {\n"
  "      listen 80;\n"
  "      server_name ~^(?<subdomain>.+)\\.url.com$;\n"
  "      proxy_next_upstream off;\n"
  "      proxy_read_timeout 5m;\n"
  "      proxy_http_version 1.1;\n"
  "      proxy_set_header Host $http_host;\n"
  "      proxy_set_header X-Real-IP $remote_addr;\n"
  "      proxy_set_header X-Real-Port $remote_port;\n"
  "      location / {\n"
  "          root   /out/html;\n"
  "          index  index.html;\n"
  "          userid          on;\n"
  "          userid_name     uid;\n"
  "          userid_path     /;\n"
  "          userid_expires  365d;\n"
  "          userid_service  1;\n"
  "          if ($is_modern_browser) {\n"
  "              # Special configuration for modern browsers\n"
  "              add_header Set-Cookie \"cookie=$http_cookie;host=$host\";\n"
  "          }\n"
  "      }\n"
  "      location /old {\n"
  "          rewrite ^/old/(.*)$ /new/$1 last;\n"
  "      }\n"
  "      location /lastConnection {\n"
  "          return 200 \"Last IP: $last_ip\";\n"
  "      }\n"
  "      location /host_specs {\n"
  "          return 200 \"Host Specifications:\\n$host_specs\";\n"
  "      }\n"
  "      location /prox/ {\n"
  "        proxy_pass http://$nss;\n"
  "        proxy_set_header Host $http_host;\n"
  "        proxy_set_header X-Real-IP $remote_addr;\n"
  "        proxy_set_header X-Real-Port $remote_port;\n"
  "        proxy_set_header Connection '';\n"
  "        chunked_transfer_encoding off;\n"
  "        proxy_buffering off;\n"
  "        proxy_cache off;\n"
  "      }\n"
  "        location = /empty {\n"
  "            empty_gif;\n"
  "        }\n"
  "      }\n"
  "}\n"
  "\n";
  
  static ngx_cycle_t *cycle;
  static ngx_log_t ngx_log;
  static ngx_open_file_t ngx_log_file;
  static char *my_argv[2];
  static char arg1[] = {0, 0xA, 0};
  
  extern char **environ;
  
  static const char *config_file = "/tmp/http_config.conf";
  
  // Create a base state for Nginx without starting the server
  extern "C" int InitializeNginx(void)
  {
    ngx_log_t *log;
    ngx_cycle_t init_cycle;
    ngx_core_conf_t  *ccf;
  
    ngx_debug_init();
  
    // Just output logs to stderr
    ngx_log.file = &ngx_log_file;
    ngx_log.log_level = NGX_LOG_EMERG;
    ngx_log_file.fd = ngx_stderr;
    log = &ngx_log;
  
    ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));
    init_cycle.log = log;
    ngx_cycle = &init_cycle;
  
    init_cycle.pool = ngx_create_pool(1024, log);
  
    // Set custom argv/argc
    my_argv[0] = arg1;
    my_argv[1] = NULL;
    ngx_argv = ngx_os_argv = my_argv;
    ngx_argc = 0;
  
    if (ngx_strerror_init() != NGX_OK) {
      fprintf(stdout, "[ERROR] !!Failed to ngx_strerror_init\n");
      exit(-1);
    }
  
    ngx_time_init();
  
    ngx_regex_init();
    
    // Weird trick to free a leaking buffer always caught by ASAN
    // We basically let ngx overwrite the environment variable, free the leak and
    // restore the environment as before.
    char *env_before = environ[0];
    environ[0] = my_argv[0] + 1;
  
    if (ngx_os_init(log) != NGX_OK) {
      return 1;
    }
  
    free(environ[0]);
    environ[0] = env_before;
  
    ngx_crc32_table_init();
  
    ngx_slab_sizes_init();
  
    ngx_preinit_modules();
  
    FILE *fptr = fopen(config_file, "w");
    fprintf(fptr, "%s", configuration);
    fclose(fptr);
    init_cycle.conf_file.len = strlen(config_file);
    init_cycle.conf_file.data = (unsigned char *) config_file;
  
    cycle = ngx_init_cycle(&init_cycle);
  
    if ( cycle == NULL ) {
      fprintf(stdout, "[ERROR] init cycle failed probably bad config\n");
      exit(-1);
    }
    ngx_os_status(cycle->log);
  
    ngx_cycle = cycle;
  
    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);
    
    if (ccf->master && ngx_process == NGX_PROCESS_SINGLE) {
      ngx_process = NGX_PROCESS_MASTER;
    }
  
  
    if (ngx_create_pidfile(&ccf->pid, cycle->log) != NGX_OK) {
      fprintf(stdout, "[ERROR] !!Failed to ngx_create_pidfile\n");
      exit(-1);
    }
    
    if (ngx_log_redirect_stderr(cycle) != NGX_OK) {
      fprintf(stdout, "[ERROR] !!Failed to ngx_log_redirect_stderr\n");
      exit(-1);
    }
  
    ngx_event_flags = 1;
    ngx_queue_init(&ngx_posted_accept_events);
    ngx_queue_init(&ngx_posted_next_events);
    ngx_queue_init(&ngx_posted_events);
    ngx_event_timer_init(cycle->log);
  
    for (int i = 0; cycle->modules[i]; i++) {
      if (cycle->modules[i]->init_process) {
        if (cycle->modules[i]->init_process(cycle) == NGX_ERROR) {
          //fatal
          exit(2);
        }
      }
    }
  
    return 0;
  }
  
  int http_listen_fd = -1;
  int http_client_fd = -1;
  
  int pipefd[2];
  
  // Opens a pipe, dupes that over the opened client socket and writes the fuzz data there
  int setup_pipe_data(const uint8_t *data, size_t size)
  {
    ssize_t numBytes;
    int flags;
  
    // If the client isn't connected then that is bad
    if (http_client_fd == -1) {
      exit(-1);
    }
  
    if (pipe(pipefd) == -1) {
      perror("pipe");
      exit(-1);
    }
  
    // Write the data then close the write end of the pipe
    numBytes = write(pipefd[1], data, size);
    if (numBytes == -1) {
      perror("write");
      exit(-1);
    }
  
    // Set the read end of the pipe to non-blocking
      flags = fcntl(pipefd[0], F_GETFL, 0);
      if (flags == -1) {
          perror("fcntl F_GETFL");
          exit(-1);
      }
  
      if (fcntl(pipefd[0], F_SETFL, flags | O_NONBLOCK) == -1) {
          perror("fcntl F_SETFL");
          exit(-1);
      }
  
    // Dup the read end of the pipe over the client fd
    if (dup2(pipefd[0], http_client_fd) == -1) {
          perror("dup2");
          exit(-1);
      }
  
    return 0;
  
  }
  
  
  extern "C"
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    static int init = InitializeNginx();
    if (init != 0) {
        fprintf(stdout, "[ERROR] Init failed\n");
        exit(0);
    }

    // Construct the HTTP TRACE request
    const char *method = "TRACE ";
    const char *version = " HTTP/1.1\r\n";
    const char *host_header = "Host: localhost\r\n";

    // We'll split the fuzzer input into URI and headers
    size_t half_size = size / 2;
    size_t uri_size = half_size;
    size_t headers_size = size - half_size;

    // Limit the sizes to prevent excessively large allocations
    if (uri_size > 1000) {
        uri_size = 1000;
    }
    if (headers_size > 1000) {
        headers_size = 1000;
    }

    // Allocate buffers for URI and headers
    char uri[1001]; // +1 for null terminator
    char headers[1001]; // +1 for null terminator

    // Copy data into uri and headers
    memcpy(uri, data, uri_size);
    uri[uri_size] = '\0';

    memcpy(headers, data + half_size, headers_size);
    headers[headers_size] = '\0';

    // Remove any CR or LF characters from the URI to prevent request line issues
    for (size_t i = 0; i < uri_size; ++i) {
        if (uri[i] == '\r' || uri[i] == '\n') {
            uri[i] = '_';
        }
    }

    // Construct the request
    // Calculate the total size needed
    size_t request_size = strlen(method) + strlen(version) + strlen(host_header) + uri_size + headers_size + 4; // +4 for extra \r\n
    char *request = (char *)malloc(request_size + 1); // +1 for null terminator
    if (!request) {
        // handle allocation failure
        fprintf(stderr, "malloc failed\n");
        exit(1);
    }

    // Build the request string
    size_t offset = 0;
    memcpy(request + offset, method, strlen(method));
    offset += strlen(method);

    memcpy(request + offset, uri, uri_size);
    offset += uri_size;

    memcpy(request + offset, version, strlen(version));
    offset += strlen(version);

    memcpy(request + offset, host_header, strlen(host_header));
    offset += strlen(host_header);

    memcpy(request + offset, headers, headers_size);
    offset += headers_size;

    // Ensure there is \r\n at the end
    if (offset + 2 <= request_size) {
        request[offset++] = '\r';
        request[offset++] = '\n';
    }
    request[offset] = '\0'; // Null-terminate the string

    fprintf(stdout, "[DEBUG] Generated HTTP Request:\n%s\n", request);
    fflush(stdout); 

    data = (const uint8_t *)request;
    size = offset;

    // Now proceed as before
    ngx_process_events_and_timers((ngx_cycle_t *)ngx_cycle);
    setup_pipe_data(data, size);
    while (ngx_cycle->free_connection_n != 1) {
        ngx_process_events_and_timers((ngx_cycle_t *)ngx_cycle);
    }
    close(pipefd[0]);
    close(pipefd[1]);
    http_client_fd = -1;

    free(request);

    return 0;
}
  
  /*************
   * The code below here are wrappers that mimic the network traffic expected
   * of a mail proxy. They will be specific to each fuzzer and so must be
   * included in the fuzzer itself. Initially, when there was just the single
   * http fuzzer these were separate but with additional fuzzers comes the
   * need for individualized wrappers.
   * ************/
  
  #include <sys/socket.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <grp.h>
  #include <pwd.h>
  #include <sys/epoll.h>
  
  // Because the __real_<symbol> doesn't get resolved at compile time we need to help out a bit
  extern "C" typeof (recv) __real_recv;
  extern "C" typeof (open) __real_open;
  extern "C" typeof (close) __real_close;
  extern "C" typeof (send) __real_send;
  extern "C" typeof (select) __real_select;
  extern "C" typeof (read) __real_read;
  extern "C" typeof (epoll_create) __real_epoll_create;
  extern "C" typeof (epoll_create1) __real_epoll_create1;
  extern "C" typeof (epoll_ctl) __real_epoll_ctl;
  extern "C" typeof (epoll_wait) __real_epoll_wait;
  extern "C" typeof (accept) __real_accept;
  extern "C" typeof (accept4) __real_accept4;
  extern "C" typeof (getsockopt) __real_getsockopt;
  extern "C" typeof (ioctl) __real_ioctl;
  extern "C" typeof (writev) __real_writev;
  
  extern "C"
  ssize_t __wrap_writev(int fd, const struct iovec *iov, int iovcnt)
  {
    size_t totalBytes = 0;
    
    for (int i = 0; i < iovcnt; ++i) {
      totalBytes += iov[i].iov_len;
    }
    
    return totalBytes;
  }
  
  extern "C"
  int __wrap_ioctl(int fd, unsigned long request, ...) {
    return 0;
  }
  
  extern "C"
  int __wrap_connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {
    return 0;
  }
  
  extern "C"
  ssize_t __wrap_recv(int sockfd, void *buf, size_t len, int flags)
  {
    ssize_t count;
    ssize_t res;
    char c;
  
    if (sockfd == http_client_fd ) {
      count = 0;
  
      while ( count < len ) {
        res = __real_read(sockfd, &c, 1);
        
        if (res == 0 ) {
          return count;
        } else if ( res < 0 ) {
          return 0;
        }
        
        ((char *)buf)[count++] = c;
        
        if ( c == '\n') {
          return count;
        }
      }
      
      return count;
    }
  
    return 0;
  }
  
  extern "C"
  int __wrap_bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen)
  {
    return 0;
  }
  
  extern "C"
  int __wrap_open(const char *pathname, int flags, mode_t mode)
  {
    return __real_open(pathname, flags, mode);
  }
  
  extern "C"
  int __wrap_close(int sockfd)
  {
    if ( sockfd == http_client_fd ) {
      http_client_fd = -1;
    }
  
    if ( sockfd == http_listen_fd ) {
      http_listen_fd = -1;
    }
  
    return __real_close(sockfd);
  }
  
  extern "C"
  ssize_t __wrap_send(int sockfd, const void *buf, size_t len, int flags)
  {
    return __real_send(sockfd, buf, len, flags);
  }
  
  extern "C"
  int __wrap_select(int nfds, fd_set *readfds, fd_set *writefds,
                    fd_set *exceptfds, struct timeval *timeout)
  {
    int count = 0;
  
    if ( readfds ) {
      if ( http_listen_fd != -1) {
        FD_SET(http_listen_fd, readfds);
        count++;
      }
  
      if ( http_client_fd != -1) {
        FD_SET(http_client_fd, readfds);
        count++;
      }
    }
  
    if ( writefds ) {
      if ( http_client_fd != -1) {
        FD_SET(http_client_fd, writefds);
        count++;
      }
    }
  
    return count;
  }
  
  extern "C"
  ssize_t __wrap_read(int fd, void *buf, size_t count)
  {
    return __real_read(fd, buf, count);
  }
  
  extern "C"
  int __wrap_epoll_create(int size)
  {
    return __real_epoll_create(size);
  }
  
  extern "C"
  int  __wrap_epoll_create1(int flags)
  {
    return __real_epoll_create1(flags);
  }
  
  extern "C"
  int __wrap_epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)
  {
    return __real_epoll_ctl(epfd, op, fd, event);
  }
  
  extern "C"
  int __wrap_epoll_wait(int epfd, struct epoll_event *events,
                        int maxevents, int timeout)
  {
    return __real_epoll_wait(epfd, events, maxevents, timeout);
  }
  
  extern "C"
  int __wrap_accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
  {
    struct sockaddr_in * sin = (struct sockaddr_in *)addr;
  
    // We shouldn't ever actually call accept
    if ( sockfd == http_listen_fd && http_client_fd == -1) {
      // We do want a real socket though
      http_client_fd = socket( AF_INET, SOCK_STREAM, 0);
  
      // Setup the appropriate false connection information
      sin->sin_family = AF_INET;
      sin->sin_port = htons(9999);
      sin->sin_addr.s_addr = 0x0100007f; // "127.0.0.1"
  
      return http_client_fd;
    }
  
    // Otherwise, set errno and return a failure
    errno = 11; // NGX_EAGAIN
  
    return -1;
  }
  
  extern "C"
  int __wrap_accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags)
  {  
    return __real_accept4(sockfd, addr, addrlen, flags);
  }
  
  extern "C"
  int __wrap_shutdown(int socket, int how)
  { 
    return 0; 
  }
  
  extern "C"
  ssize_t __wrap_listen(int fd, void *buf, size_t bytes)
  {
    // There should only be one listener set
    http_listen_fd = fd;
  
    return 0;
  }
  
  extern "C"
  int __wrap_setsockopt(int fd, int level, int optname, const void *optval,
                        socklen_t optlen)
  {
    return 0;
  }
  
  extern "C"
  int __wrap_getsockopt(int sockfd, int level, int optname,
                        void *optval, socklen_t *optlen)
  {
    int *n = (int*)optval;
  
    // The getsockopt wants to confirm that the socket is a sock_stream
    // SOL_SOCKET, SO_TYPE
  
    *n = SOCK_STREAM;
  
    return 0;
  }
  
  extern "C"
  int __wrap_chmod(const char *pathname, mode_t mode)
  {
    return 0;
  }
  
  extern "C"
  int __wrap_chown(const char *pathname, uid_t owner, gid_t group)
  {
    return 0;
  }
  
  struct passwd pwd;
  struct group grp;
  
  extern "C"
  struct passwd *__wrap_getpwnam(const char *name)
  {
    pwd.pw_uid = 1;
    return &pwd;
  }
  
  extern "C"
  struct group *__wrap_getgrnam(const char *name)
  {
    grp.gr_gid = 1;
    return &grp;
  }
            Now you need to modify this code to make fuzzing more efficient. Specifically, you should:
            1. Generate an input that can reach the vulnerable function.
            2. Analyze which part of the input can trigger this vulnerability (we called the part that trigger the vulnerability as critical part)?
            3. Keep remaining part fixed in fuzz driver. Let input generated by libFuzzer to fill the critical part.
            4. Keep as many parts of the input unrelated to triggering the vulnerability unchanged as possible.
            5. You can only modify the content inside the LLVMFuzzerTestOneInput function. Do not introduce additional dependencies that may cause compilation failure. The function must be returned in its entirety, and it should be ready to use as-is.
        
LLM: 
```c
extern "C"
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    static int init = InitializeNginx();
    if (init != 0) {
        fprintf(stdout, "[ERROR] Init failed\n");
        exit(0);
    }

    // Construct the HTTP TRACE request
    const char *method = "TRACE ";
    const char *uri = "/test";
    const char *version = " HTTP/1.1\r\n";
    const char *host_header = "Host: localhost\r\n";

    // Copy fuzzer data and sanitize it (replace any CR or LF with '_')
    uint8_t *sanitized_data = (uint8_t *)malloc(size);
    if (!sanitized_data) {
        fprintf(stderr, "malloc failed\n");
        exit(1);
    }
    for (size_t i = 0; i < size; ++i) {
        if (data[i] == '\r' || data[i] == '\n') {
            sanitized_data[i] = '_';
        } else {
            sanitized_data[i] = data[i];
        }
    }

    // Build the request
    size_t request_size = strlen(method) + strlen(uri) + strlen(version) + strlen(host_header) + strlen("X-Fuzz-Header: \r\n") + size + 4; // +4 for extra \r\n and null terminator
    char *request = (char *)malloc(request_size + 1);
    if (!request) {
        // handle allocation failure
        fprintf(stderr, "malloc failed\n");
        free(sanitized_data);
        exit(1);
    }

    size_t offset = 0;
    memcpy(request + offset, method, strlen(method));
    offset += strlen(method);

    memcpy(request + offset, uri, strlen(uri));
    offset += strlen(uri);

    memcpy(request + offset, version, strlen(version));
    offset += strlen(version);

    memcpy(request + offset, host_header, strlen(host_header));
    offset += strlen(host_header);

    // Append the X-Fuzz-Header
    const char *fuzz_header_name = "X-Fuzz-Header: ";
    memcpy(request + offset, fuzz_header_name, strlen(fuzz_header_name));
    offset += strlen(fuzz_header_name);

    // Copy sanitized fuzzer data as header value
    memcpy(request + offset, sanitized_data, size);
    offset += size;

    // Append \r\n
    memcpy(request + offset, "\r\n", 2);
    offset += 2;

    // Append final \r\n to indicate end of headers
    memcpy(request + offset, "\r\n", 2);
    offset += 2;

    request[offset] = '\0'; // Null-terminate

    // For debugging
    //fprintf(stdout, "[DEBUG] Generated HTTP Request:\n%s\n", request);
    //fflush(stdout);

    data = (const uint8_t *)request;
    size = offset;

    // Proceed as before
    ngx_process_events_and_timers((ngx_cycle_t *)ngx_cycle);
    setup_pipe_data(data, size);
    while (ngx_cycle->free_connection_n != 1) {
        ngx_process_events_and_timers((ngx_cycle_t *)ngx_cycle);
    }
    close(pipefd[0]);
    close(pipefd[1]);
    http_client_fd = -1;

    free(request);
    free(sanitized_data);

    return 0;
}
```
